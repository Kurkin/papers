#+OPTIONS: ':nil *:t -:t ::t <:t H:nil \n:nil ^:nil arch:headline author:nil
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:nil e:t
#+OPTIONS: email:nil f:t inline:t num:nil p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:nil title:nil toc:nil todo:t |:t
#+TITLE: Converting a State Machine to a C++ 20 Coroutine
#+AUTHOR: Steve Downey
#+EMAIL: sdowney2@bloomberg.net, sdowney@gmail.com
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_COMPILER: pdflatex
#+DATE: <2021-01-20 Wed>
#+STARTUP: showall
#+OPTIONS: html-link-use-abs-url:nil html-postamble:nil html-preamble:t
#+OPTIONS: html-scripts:t html-style:t html5-fancy:nil tex:t
#+HTML_DOCTYPE: xhtml-strict
#+HTML_CONTAINER: div
#+DESCRIPTION:
#+KEYWORDS:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+HTML_HEAD:
#+HTML_HEAD_EXTRA:
#+SUBTITLE:
#+INFOJS_OPT:
#+OPTIONS: reveal_width:1600 reveal_height:900
#+REVEAL_THEME: black
#+REVEAL_MATHJAX_URL: https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://sdowney.org/css/smd-zenburn.css" />
#+REVEAL_EXTRA_CSS: http://sdowney.org/css/smd-zenburn.css
#+REVEAL_TITLE_SLIDE_BACKGROUND: http://sdowney.org/images/CrashCourseTitle.png

#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_VERSION: 4

* Abstract
  C++ 20 coroutines can naturally express in linear code components that are today written as state machines that wait on async operations. This talk walks through using the low-level machinery and customization points in C++ 20 to convert a state machine, which waits at the end of steps for async service operations to complete, into a single coroutine that `co_awaits` those operations.


* The core coroutine transform is to a state machine
** The Transform
   C++ 20 coroutines are resumable functions.
   A coroutine is transformed into
   - a handle to the frame holding the stack variables
   - an indicator of where to resume
** State is maintained in the coroutine frame
   The coroutine frame is equivalent to the member variables of an object.
** ~co_await~ points are the states
   The coroutine is waiting for input.
** Resumptions are transitions firing
   When a transition fires the coroutine can decide how to proceed to the next state.

* State machines are more than regexps
  Regular expressions are often, even usually, implemented as state machines.

  The state machine is built automatically.

  Very large state machines need tools to manage them.

  Most state machines are small.

* A bit of theory
** UML State Diagrams
** Harel State Charts
** Model, not necessarily Code
** But it was Aliens

* Most state machines are simple
** Golden Path, Error Path, Failure Path
   - Things go well
   - Things go badly in expected ways
     * Bad input
     * File Not Found
   - Things go badly in unexpected ways
     * 2 + 2 == 5
** Rule of 5 to 9 and resorting to state machine tools
   We can genererally hold 7 plus or minus 2 things in our heads.

   More than that and the structure in our head collapses.

   5 to 9 states can be maintained by hand.

   100s or 1000s can not.

** Generality might mean `goto`
   If states can be reached from any other state, the code might need a ~goto~.

   Forward or backward.

   It will not need to leave the scope of the machine / coroutine.

** Suspension and Decision
   Guarded transitions are just if tests after a suspension point.

* No std library solutions
  We don't have coroutine types in the standard.

  We hope to have some for C++23.
** Handcrafting types not wrong
   The machinery is available for a reason.

   These are tools for library writers.

   Not Standard Library writers.

** Influences standardization
   We want general and proven tools in the library.

   We get those by seeing what actually works.

** Will continue to work
   If the standard adopts some std::coro_state_machine it will not break yours.

   If the standard never adopts some std::coro_state_machine it will not break yours.
* Code: simple multistep async operations
  Not actual production code, but I have real code like this.
  #+begin_src c++
class CreateUser {
    CreateUser(std::string user);
    // ....
};
  #+end_src
** Lookup user or create
   #+begin_src c++
Result CreateUser::findUser() {}
   #+end_src
** Validate request with "compliance"
   #+begin_src c++
Result CreateUser::okToCreate() {}
   #+end_src
** Broadcast Operation
   #+begin_src c++
Result CreateUser::broadcastNewUser() {}
   #+end_src
** Return status for request
   #+begin_src c++
Result CreateUser::endTransaction() {}
   #+end_src
** Natural non-async code is the inverse coroutine transform
** while not done
   Externally this is driven checking if the object said it was done, and if not, scheduling the next operation.

* Async Callbacks and Threads
** Callback signature
   #+begin_src c++
void (*callback)(void* context, void* response, void* error);
void install(callback cb, void* context);

   #+end_src
   Typical generic C-ish call back interface.

   - You give the framework the context to give back to you,
   - it gives you the response you were waiting for
   - alternatively or additionally it tells you about any errors

** Context: this pointer or coroutine frame -- Yes
   For a C++ mechanism, the ~this~ pointer is often the context, and you cast back to the known type.
** Whose thread is this anyway - rescheduling
** Making an awaitable for a primitive async call

* Coroutines are NOT async
** Suspension is not async
** Transfer of control is sync
** Coroutines are deterministic
** Async is external to the coroutine

* Code: This looks like what you expect
** Changes to machinery
** Logic is clearer
** Writing new async state machines easier
