#+OPTIONS: ':nil *:t -:t ::t <:t H:nil \n:nil ^:nil arch:headline author:nil
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:nil e:t
#+OPTIONS: email:nil f:t inline:t num:nil p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:nil title:nil toc:nil todo:t |:t
#+TITLE:
#+AUTHOR:
#+EMAIL:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+KEYWORDS:
#+DESCRIPTION:
#+SUBTITLE:
#+LATEX_COMPILER: pdflatex
#+DATE:
#+STARTUP: showeverything
#+OPTIONS: html-link-use-abs-url:nil html-postamble:nil html-preamble:t
#+OPTIONS: html-scripts:t html-style:t html5-fancy:nil tex:t
#+HTML_DOCTYPE: xhtml-strict
#+HTML_CONTAINER: div
#+DESCRIPTION:
#+KEYWORDS:
#+HTML_LINK_HOME:
#+HTML_LINK_UP:
#+HTML_MATHJAX:
#+HTML_HEAD:
#+HTML_HEAD_EXTRA:
#+SUBTITLE:
#+INFOJS_OPT:
#+OPTIONS: reveal_width:1600 reveal_height:900
#+REVEAL_THEME: black
#+REVEAL_MATHJAX_URL: https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://sdowney.org/css/smd-zenburn.css" />
#+REVEAL_EXTRA_CSS: http://sdowney.org/css/smd-zenburn.css
#+REVEAL_TITLE_SLIDE_BACKGROUND: http://sdowney.org/images/cppcon21.png

#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_VERSION: 4



* An Algebraic Bestiary
Sums, Products, Exponents, Monoids, Functors, Oh My!

Why Should I Care?—Or—Abstract Nonsense in Practice


* Types and Structures
** Algebraic Types
   Composition of Types
** Basic Structures
   Patterns of Operations on Types
** Categorical Structures
   Patterns of Composition of Operations

* Algebraic Types
** Counting how many objects in a type
** Product Types
   - Structs
   - Pairs
   - Tuples
** Sum Typles
   - Unions
   - Variants
   - Optional/Expected
** Exponential Types
   Functions from A to B are B^A
*** Example of Functions
    $A \rightarrow Bool$

    Let $A$ have three elements \(a_0, a_1, a_2\)

    The eight possible functions are defined by this table

    |         | $a_0$   | $a_1$   | $a_2$   |
    |---------+---------+---------+---------|
    | $f_0()$ | $true$  | $true$  | $true$  |
    | $f_1()$ | $true$  | $true$  | $false$ |
    | $f_2()$ | $true$  | $false$ | $true$  |
    | $f_3()$ | $true$  | $false$ | $false$ |
    | $f_4()$ | $false$ | $true$  | $true$  |
    | $f_5()$ | $false$ | $true$  | $false$ |
    | $f_6()$ | $false$ | $false$ | $true$  |
    | $f_7()$ | $false$ | $false$ | $false$ |

** "The Same Type"
*** Isomorphism
    Same Shape

    Mapping in both directions
*** Normal Form is Sum of Products
    Types with the Same NF are Isomorphic
** Examples of Type Formulas
   | Type                        | Formula      |
   |-----------------------------+--------------|
   | optional<A>                 | $1 + A$      |
   | pair<A,B>                   | $A \times B$ |
   | monostate                   | $1$          |
   | bool                        | $2$          |
   | {true, false, FileNotFound} | $3$          |
   | struct {A a; B b};          | $A \times B$ |
   | (A) -> B                    | $B ^ A$      |
   | union {A a; B b};           | $A + B$      |
   | variant<A, B, C>            | $A + B + C$  |
   |                             |              |
** Formula Manipulation
   | Type          |               | Formula                       |
   |---------------+---------------+-------------------------------|
   | variant<A, A> | $\Rightarrow$ | $A + A \Rightarrow 2A$        |
   | pair<bool, A> | $\Rightarrow$ | $2 \times A \Rightarrow 2A$   |
   |               |               |                               |

   A tagged pair is equivalent to a variant

** Tuple
   | Type           |               | Formula     |
   |----------------+---------------+-------------|
   | tuple<A, A, A> | $\Rightarrow$ | $A x A x A$ |
   |                |               | $A ^ 3$     |
   |                |               |             |
   | 3 -> A         | $\Rightarrow$ | $A ^ 3$     |
   |                |               |             |

   A function that takes an index and returns an A is equivalent to a 3-tuple, or Array
** Recursive Types
   A list is either null or a value followed by a list

   $L = 1 + AL$

   We can expand in L

   \begin{equation}
   L = 1 + A(1 + AL)
   \end{equation}
   \begin{equation}
   L = 1 + A + AAL
   \end{equation}
   \begin{equation}
   L = 1 + A + AA + AAAL
   \end{equation}
   \begin{equation}
   L = 1 + A + AA + AAA + AAAAL
   \end{equation}

   So a list of A is either nil or A or two A or three A and so on

** Calculus
   It's been recently demonstrated that the first derivative of an algebraic type is the type of its one hole context, which is the "zipper" datatype

* Types with Operation(s)
  These kinds of structures guide not only how operations should behave, but also inform what constructors should be provided for a type

[[./Algebraic_structures_-_magma_to_group.svg]]

** One Type and an operation $(A, A) \Rightarrow A$
  Three 'interesting' properties of the operation
  - Associativity ::
    \begin{align*}
    &a + (b + c) = (a + b) + c \\
    &op(a, op(b, c)) = op(op(a, b), c) \\
    \end{align*}
  - Identity :: There exists an element of A such that $a + i =  a$
  - Inverse :: For all elements of A, there exists an element $a'$ such that $a + a' = i$

**  Also sometimes

  - Commutivity (sometimes) :: $(a + b) == (b + a)$

** The Taxonomy
   | Name              | Associativity | Identity | Inverse |
   |-------------------+---------------+----------+---------|
   | Magma             | No            | No       | No      |
   | Semigroup         | Yes           | No       | No      |
   | Monoid            | Yes           | Yes      | No      |
   | Group             | Yes           | Yes      | Yes     |
   | Unital Magma      | No            | Yes      | No      |
   | Quasigroup        | No            | No       | Yes     |
   | Loop              | No            | Yes      | Yes     |
   | Inverse Semigroup | Yes           | No       | Yes     |

   Abelian Group adds Commutivity to Group (or monoid, or semigroup)

   Two of these are interesting to C++ Programmers

** One has a direct impact on code: Monoid
   It shows up because it means we can work by parts in any order and we have an initial element

   Folds, tree operations, scans, etc

   We don't have a standard function that can return the identity, sometimes called mzero

   We do have a default constructor

   If you are creating a type and operation to be a monoid, make the default constructor create the zero (or 1) element

** Abelian Group
   For groups there are no good ways to signal the pattern in C++

   We say Concepts have semantic requirements. That means bugs that aren't caught

   Being able to replace $op(a,b)$ with $op(b,a)$ can substantially simplify and improve parallel and concurrent algorithms

* Categorical Structures
  Category theory studies morphisms, or arrows, largely ignoring the objects. It's concerned with how operations compose, and what structures allow us to reason about those compositions

  Category theory has provided many useful results, and a lot of terrible names

  These are generic types, over some underlying type. In C++ terms something like
  #+begin_src C++
  template class T<typename A>
  #+end_src

  Composed functions are what defines the structures
** Function composition
   Because not everyone agrees everywhere

   The composition of two functions

   $f(g(x))$

   is written

   $f \circ g$

   and has the type

   $(\beta \rightarrow \gamma) \rightarrow (\alpha \rightarrow \beta) \rightarrow (\alpha \rightarrow \gamma)$

   A function from $\beta$ to $\gamma$ and a function from $\alpha$ to $\beta$ compose to form a function from $\alpha$ to $\gamma$.
*** C++
    #+begin_src C++
auto circ(auto&& f, auto&& g) {
    return [=](auto&& x) { return f(g(x)); };
}
    #+end_src



** Functor
   A functor allows a function to be mapped in to the type

   in such a way that it composes sensibly

   Containers are natural Functors

   Not all Functors are Containers

*** Interface
    - fmap or transform ::
   \begin{equation}
    (A \rightarrow B) \rightarrow T \langle A \rangle \rightarrow T \langle B \rangle
   \end{equation}

   Apply a function of type A to B to a ~functor~ over A producing a ~functor~ of B

*** Laws
#+begin_src haskell
fmap id = id
fmap (g . h) = (fmap g) . (fmap h)
#+end_src

    src_C++[:exports code]{transform(functor, std::identity)}

$\Updownarrow$

    src_C++[:exports code]{std::identity(functor)}

    src_C++[:exports code]{transform(functor, circ(g, h))}

$\Updownarrow$

    src_C++[:exports code]{circ(transform(functor, g), transform(functor, h))}


*** C++
#+begin_src C++
    std::transform
    std::optional::transform
#+end_src

Advice: If your type is Container like, make it a Range or provide a Range Adaptor

Advice: If it's not a Container, name the operation `transform`

# ** Applicative (unusual in C++)

# Applicative functors arise most naturally out of partial application.

# Partial application is not entirely normal in C++.

# Start with a ~list~ of values, and a function that takes that value, and continue in parallel.

# *** Interface

# *** Laws

# *** C++
** Monad
Monads allow functions returning the type of the monad to be bound into an instance of the monad, or for two functions that return monads over different types to be chained together

A monadic type over the same monadic type can be 'flattened' into the underlying monad

Monads are also Functors
*** Interface
- bind or and_then ::
  \begin{equation}
  M \langle a \rangle \rightarrow (a \rightarrow M \langle b \rangle ) \rightarrow M \langle b \rangle
  \end{equation}

- fish or kleisli arrow  ::
  \begin{equation}
  (a \rightarrow M \langle b \rangle ) \rightarrow (b \rightarrow M \langle c \rangle ) \rightarrow (a \rightarrow M \langle c \rangle )
  \end{equation}

- flatten or mconcat ::
  \begin{equation}
  M \langle M \langle a \rangle \rangle \rightarrow  M \langle a \rangle
  \end{equation}

*** Applicative and Functor
- make or pure or return ::
  \begin{equation}
  M \langle a  \rangle \rightarrow  M \langle a \rangle
  \end{equation}

- fmap or transform ::
   \begin{equation}
    (a \rightarrow b) \rightarrow M \langle a \rangle \rightarrow M \langle b \rangle
   \end{equation}

Any one of the first three and one of the second two can define the other three

*** Laws

- left identity :: bind(pure(a), h) == h(a)
- right identity :: bind(m, pure) == m
- associativity :: bind(bind(m, g), h) == bind(m, bind((\x -> g(x), h))

*** C++

#+begin_src C++
template<class A> optional {
    // ...
    template <class F> constexpr auto and_then(F&& f);
    template <class F> constexpr auto transform(F&& f);
    // ...
};
#+end_src

* Any Questions?

Or Comments?


* Thank You!
